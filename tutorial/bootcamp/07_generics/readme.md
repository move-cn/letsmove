## èµ„æ–™
- [PPT](https://docs.google.com/presentation/d/1mTSYySPi0fClm7_RRryrEC4pkrb8gip-z6ziJxP8Hwc)


# Generics èŒƒå‹

Generics åœ¨è®¡ç®—æœºæœ¯è¯­ä¸­è¢«ç§°ä¸ºèŒƒå‹ï¼Œå¼•ç”¨ [Rust Book](https://doc.rust-lang.org/stable/book/ch10-00-generics.html) å¯¹äºæ³›å‹çš„å®šä¹‰ï¼š*æ³›å‹æ˜¯å…·ä½“ç±»å‹æˆ–å…¶ä»–å±æ€§çš„æŠ½è±¡æ›¿ä»£å“*ã€‚èŒƒå‹ä½¿å¾—åœ¨ç¼–å†™ Move ä»£ç æ—¶æä¾›æ›´å¼ºçš„çµæ´»æ€§ï¼Œå¹¶é¿å…é€»è¾‘é‡å¤ã€‚

å®é™…ä¸Šï¼Œæ³›å‹å…è®¸æˆ‘ä»¬åªç¼–å†™å•ä¸ªå‡½æ•°ï¼Œå†™ä¸€å¥—é€»è¾‘ï¼Œè€Œåº”ç”¨äºä»»ä½•ç±»å‹ä¸Šã€‚æ‰€ä»¥è¿™ç§å‡½æ•°ä¹Ÿè¢«ç§°ä¸ºæ¨¡æ¿ â€”â€”ä¸ªå¯ä»¥åº”ç”¨äºä»»ä½•ç±»å‹çš„æ¨¡æ¿å¤„ç†ç¨‹åºã€‚

èŒƒå‹æ˜¯ Move ä¸­çš„ä¸€ä¸ªå…³é”®æ¦‚å¿µï¼Œç†è§£å¹¶å¯¹å…¶å·¥ä½œåŸç†ä¿æŒç›´è§‰éå¸¸é‡è¦ï¼Œå› æ­¤è¯·èŠ±ç‚¹æ—¶é—´é˜…è¯»æœ¬èŠ‚å¹¶å……åˆ†ç†è§£æ¯ä¸ªéƒ¨åˆ†ã€‚

## **èŒƒå‹ç”¨æ³•**

### åœ¨æ¶æ„ä¸­ä½¿ç”¨èŒƒå‹

çœ‹ä¸€ä¸ªåŸºæœ¬ç¤ºä¾‹ï¼Œäº†è§£å¦‚ä½•ä½¿ç”¨ Generics åˆ›å»ºä¸€ä¸ªå¯ä»¥å®¹çº³ Sui Move ä¸­ä»»ä½•ç±»å‹çš„å®¹å™¨ `Box` ã€‚

é¦–å…ˆï¼Œåœ¨æ²¡æœ‰èŒƒå‹çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªåŒ…å«  `u64` ç±»å‹çš„ `Box`ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```move
module generics::obj_generics {
   public struct Box {
        value: u64
    }
}
```

ä½†æ˜¯ï¼Œè¿™ç§ç±»å‹åªèƒ½ä¿å­˜ u64 ç±»å‹çš„å€¼ï¼Œä¸ºäº†èƒ½å¤Ÿå­˜å‚¨å…¶ä»–ç±»å‹æ˜¾ç„¶æˆ‘ä»¬ä¸èƒ½æŠŠæ‰€æœ‰ç±»å‹çš„boxéƒ½æšä¸¾å®Œï¼Œæ‰€ä»¥è¿™ä¸ªæ—¶å€™å°±éœ€è¦ä½¿ç”¨æ³›å‹ã€‚ ä»£ç å°†ä¿®æ”¹å¦‚ä¸‹ï¼š

```move
module generics::obj_generics {
    public struct Box<T> {
        value: T
    }
}


```

#### èƒ½åŠ›é™åˆ¶

æˆ‘ä»¬å¯ä»¥æ·»åŠ æ¡ä»¶å»å¼ºåˆ¶ä¼ é€’ç»™æ³›å‹çš„ç±»å‹å¿…é¡»å…·æœ‰æŸäº›èƒ½åŠ›ã€‚ è¯­æ³•å¦‚ä¸‹æ‰€ç¤ºï¼š

```move
module generics::obj_generics {
    // T must be copyable and droppable 
    public struct Box<T: store + drop> has key, store {
        value: T
    }
}
```

ğŸ’¡è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç”±äºå¤–éƒ¨å®¹å™¨ç±»å‹ï¼Œä¸Šä¾‹ä¸­çš„å†…éƒ¨ç±»å‹ T å¿…é¡»æ»¡è¶³ä¸€å®šçš„èƒ½åŠ›çº¦æŸã€‚ åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`T` å¿…é¡»æœ‰ `store`ï¼Œå› ä¸º `Box` æœ‰ `store` å’Œ `key`ã€‚ ä½†æ˜¯ï¼Œ`T` ä¹Ÿå¯ä»¥å…·æœ‰å®¹å™¨æ²¡æœ‰çš„èƒ½åŠ›ï¼Œå¦‚æœ¬ä¾‹ä¸­çš„ `drop`ã€‚

ç›´è§‰æ˜¯ï¼Œå¦‚æœå…è®¸å®¹å™¨åŒ…å«ä¸€ä¸ªä¸éµå¾ªå®ƒæ‰€éµå¾ªçš„ç›¸åŒè§„åˆ™çš„ç±»å‹ï¼Œå®¹å™¨å°†è¿åå…¶è‡ªèº«çš„èƒ½åŠ›ã€‚ å¦‚æœç›’å­é‡Œçš„ä¸œè¥¿ä¸èƒ½è¢«å‚¨å­˜ï¼Œé‚£ç›’å­æ€ä¹ˆèƒ½è¢«å‚¨å­˜å‘¢ï¼Ÿ

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå¯ä»¥ä½¿ç”¨ä¸€ç§ç§°ä¸º`phantom` çš„ç‰¹æ®Šå…³é”®å­—æ¥ç»•è¿‡æ­¤è§„åˆ™ã€‚


### åœ¨å‡½æ•°ä¸­ä½¿ç”¨Generics

è¦ç¼–å†™ä¸€ä¸ªè¿”å› Box å®ä¾‹çš„å‡½æ•°ï¼Œè¯¥å®ä¾‹å¯ä»¥ä¸º value å­—æ®µæ¥å—ä»»ä½•ç±»å‹çš„å‚æ•°ï¼Œæˆ‘ä»¬è¿˜å¿…é¡»åœ¨å‡½æ•°å®šä¹‰ä¸­ä½¿ç”¨æ³›å‹ã€‚ è¯¥å‡½æ•°å¯ä»¥å®šä¹‰å¦‚ä¸‹ï¼š

```rust
public fun create_box<T>(value: T): Box<T> {
        Box<T> { value }
    }
```

å¦‚æœæˆ‘ä»¬æƒ³é™åˆ¶å‡½æ•°åªæ¥å—ç‰¹å®šç±»å‹çš„ valueï¼Œæˆ‘ä»¬åªéœ€åœ¨å‡½æ•°ç­¾åä¸­æŒ‡å®šè¯¥ç±»å‹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
public fun create_box(value: u64): Box<u64> {
        Box<u64>{ value }
    }
```

è¿™å°†åªæ¥å— u64 ç±»å‹çš„è¾“å…¥ï¼Œä¸ºäº†ä½¿ç”¨ `create_box` çš„æ–¹æ³•ï¼ŒåŒæ—¶ä»ç„¶ä½¿ç”¨åŒæ ·çš„æ³›å‹ Box ç»“æ„ã€‚

#### ä½¿ç”¨Genericsè°ƒç”¨å‡½æ•°

è¦è°ƒç”¨å¸¦æœ‰åŒ…å«æ³›å‹çš„ç­¾åçš„å‡½æ•°ï¼Œæˆ‘ä»¬å¿…é¡»åœ¨æ–¹æ‹¬å·ä¸­æŒ‡å®šç±»å‹ï¼Œå¦‚ä»¥ä¸‹è¯­æ³•æ‰€ç¤ºï¼š

```rust
// value will be of type Storage::Box<bool>
    let bool_box = storage::create_box<bool>(true);
// value will be of the type Storage::Box<u64>
    let u64_box = storage::create_box<u64>(1000000);
```

#### ä½¿ç”¨è¿ç”¨Sui CLIçš„Genericsè°ƒç”¨å‡½æ•°

è¦ä» Sui CLI è°ƒç”¨å…¶ç­¾åä¸­å¸¦æœ‰æ³›å‹çš„å‡½æ•°ï¼Œæ‚¨å¿…é¡»ä½¿ç”¨æ ‡å¿— `--type-args` å®šä¹‰å‚æ•°çš„ç±»å‹ã€‚

ä»¥ä¸‹ç¤ºä¾‹è°ƒç”¨ `create_box` å‡½æ•°åˆ›å»ºä¸€ä¸ªç›’å­ï¼Œå…¶ä¸­åŒ…å« `0x2::sui::SUI` ç±»å‹çš„ç¡¬å¸ï¼š

```bash
sui client call --package $PACKAGE --module $MODULE --function "create_box" --args $OBJECT_ID --type-args "0x2::coin::Coin<0x2::sui::SUI>" 
```

## é«˜çº§ Generics è¯­æ³•

æ³›å‹
æ³›å‹æ˜¯ä¸€ç§å®šä¹‰å¯ä»¥ä¸ä»»ä½•ç±»å‹ä¸€èµ·ä½¿ç”¨çš„ç±»å‹æˆ–å‡½æ•°çš„æ–¹æ³•ã€‚å½“æ‚¨æƒ³è¦ç¼–å†™å¯ä¸ä¸åŒç±»å‹ä¸€èµ·ä½¿ç”¨çš„å‡½æ•°æ—¶ï¼Œæˆ–è€…å½“æ‚¨æƒ³è¦å®šä¹‰å¯ä»¥å®¹çº³ä»»ä½•å…¶ä»–ç±»å‹çš„ç±»å‹æ—¶ï¼Œè¿™éå¸¸æœ‰ç”¨ã€‚æ³›å‹æ˜¯ Move ä¸­è®¸å¤šé«˜çº§åŠŸèƒ½çš„åŸºç¡€ï¼Œä¾‹å¦‚é›†åˆã€æŠ½è±¡å®ç°ç­‰ã€‚

åœ¨æ ‡å‡†åº“ä¸­
åœ¨æœ¬ç« ä¸­æˆ‘ä»¬å·²ç»æåˆ°äº†å‘é‡ç±»å‹ï¼Œå®ƒæ˜¯å¯ä»¥å®¹çº³ä»»ä½•å…¶ä»–ç±»å‹çš„æ³›å‹ç±»å‹ã€‚æ ‡å‡†åº“ä¸­æ³›å‹ç±»å‹çš„å¦ä¸€ä¸ªç¤ºä¾‹æ˜¯ Optionç±»å‹ï¼Œå®ƒç”¨äºè¡¨ç¤ºå¯èƒ½å­˜åœ¨æˆ–ä¸å­˜åœ¨çš„å€¼ã€‚

é€šç”¨è¯­æ³•
<è¦å®šä¹‰æ³›å‹ç±»å‹æˆ–å‡½æ•°ï¼Œç±»å‹ç­¾åéœ€è¦åŒ…å«ç”¨å°–æ‹¬å· (å’Œ)æ‹¬èµ·æ¥çš„æ³›å‹å‚æ•°åˆ—è¡¨>ã€‚é€šç”¨å‚æ•°ä»¥é€—å·åˆ†éš”ã€‚
```rust
/// Container for any type `T`.
public struct Container<T> has drop {
    value: T,
}

/// Function that creates a new `Container` with a generic value `T`.
public fun new<T>(value: T): Container<T> {
    Container { value }
}
```

åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼ŒContaineræ˜¯å…·æœ‰å•ä¸ªç±»å‹å‚æ•°çš„æ³›å‹ç±»å‹Tï¼Œvalue å®¹å™¨çš„å­—æ®µå­˜å‚¨T.è¯¥newå‡½æ•°æ˜¯å…·æœ‰å•ä¸ªç±»å‹å‚æ•°çš„æ³›å‹å‡½æ•°Tï¼Œå¹¶ä¸”å®ƒè¿”å›Containerå…·æœ‰ç»™å®šå€¼çš„ a ã€‚æ³›å‹ç±»å‹å¿…é¡»ä½¿ç”¨å…·ä½“ç±»å‹è¿›è¡Œåˆå§‹åŒ–ï¼Œå¹¶ä¸”æ³›å‹å‡½æ•°å¿…é¡»ä½¿ç”¨å…·ä½“ç±»å‹è¿›è¡Œè°ƒç”¨ã€‚
```rust
#[test]
fun test_container() {
// these three lines are equivalent
let container: Container<u8> = new(10); // type inference
let container = new<u8>(10); // create a new `Container` with a `u8` value
let container = new(10u8);

    assert!(container.value == 10, 0x0);

    // Value can be ignored only if it has the `drop` ability.
    let Container { value: _ } = container;
}
```

åœ¨æµ‹è¯•å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬æ¼”ç¤ºäº†ä¸‰ç§ç­‰æ•ˆçš„æ–¹æ³•æ¥åˆ›å»ºå…·æœ‰å€¼ çš„test_genericæ–°å€¼ã€‚ç”±äºéœ€è¦æ¨æ–­æ•°å­—ç±»å‹ï¼Œå› æ­¤æˆ‘ä»¬æŒ‡å®šæ•°å­—æ–‡å­—çš„ç±»å‹ã€‚Containeru8

å¤šç§ç±»å‹å‚æ•°
æ‚¨å¯ä»¥å®šä¹‰å…·æœ‰å¤šä¸ªç±»å‹å‚æ•°çš„ç±»å‹æˆ–å‡½æ•°ã€‚ç„¶åç±»å‹å‚æ•°ç”¨é€—å·åˆ†éš”ã€‚

```rust
/// A pair of values of any type `T` and `U`.
public struct Pair<T, U> {
    first: T,
    second: U,
}

/// Function that creates a new `Pair` with two generic values `T` and `U`.
public fun new_pair<T, U>(first: T, second: U): Pair<T, U> {
    Pair { first, second }
}
```


åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œæ˜¯å…·æœ‰ä¸¤ä¸ªç±»å‹å‚æ•°å’ŒPairçš„æ³›å‹ç±»å‹ï¼Œå¹¶ä¸”è¯¥ å‡½æ•°æ˜¯å…·æœ‰ä¸¤ä¸ªç±»å‹å‚æ•°å’Œçš„æ³›å‹å‡½â€‹â€‹æ•°ã€‚è¯¥å‡½æ•°è¿”å›å…·æœ‰ç»™å®šå€¼çš„ aã€‚ç±»å‹å‚æ•°çš„é¡ºåºå¾ˆé‡è¦ï¼Œå®ƒåº”è¯¥ä¸ç±»å‹ç­¾åä¸­ç±»å‹å‚æ•°çš„é¡ºåºåŒ¹é…ã€‚TUnew_pairTUPair

```rust
#[test]
fun test_generic() {
// these three lines are equivalent
let pair_1: Pair<u8, bool> = new_pair(10, true); // type inference
let pair_2 = new_pair<u8, bool>(10, true); // create a new `Pair` with a `u8` and `bool` values
let pair_3 = new_pair(10u8, true);

    assert!(pair_1.first == 10, 0x0);
    assert!(pair_1.second, 0x0);

    // Unpacking is identical.
    let Pair { first: _, second: _ } = pair_1;
    let Pair { first: _, second: _ } = pair_2;
    let Pair { first: _, second: _ } = pair_3;

}
```

å¦‚æœæˆ‘ä»¬æ·»åŠ å¦ä¸€ä¸ªå®ä¾‹ï¼Œåœ¨å‡½æ•°ä¸­äº¤æ¢ç±»å‹å‚æ•°new_pairï¼Œå¹¶å°è¯•æ¯”è¾ƒä¸¤ç§ç±»å‹ï¼Œæˆ‘ä»¬ä¼šå‘ç°ç±»å‹ç­¾åä¸åŒï¼Œå¹¶ä¸”æ— æ³•è¿›è¡Œæ¯”è¾ƒã€‚
```rust
#[test]
fun test_swap_type_params() {
let pair1: Pair<u8, bool> = new_pair(10u8, true);
let pair2: Pair<bool, u8> = new_pair(true, 10u8);

    // this line will not compile
    // assert!(pair1 == pair2, 0x0);

    let Pair { first: pf1, second: ps1 } = pair1; // first1: u8, second1: bool
    let Pair { first: pf2, second: ps2 } = pair2; // first2: bool, second2: u8

    assert!(pf1 == ps2, 0x0); // 10 == 10
    assert!(ps1 == pf2, 0x0); // true == true
}
```


å˜é‡pair1å’Œçš„ç±»å‹pair2ä¸åŒï¼Œæ¯”è¾ƒå°†æ— æ³•ç¼–è¯‘ã€‚

ä¸ºä»€ä¹ˆè¦æ³›å‹ï¼Ÿ
åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬é‡ç‚¹å…³æ³¨å®ä¾‹åŒ–æ³›å‹ç±»å‹å¹¶è°ƒç”¨æ³›å‹å‡½æ•°æ¥åˆ›å»ºè¿™äº›ç±»å‹çš„å®ä¾‹ã€‚ç„¶è€Œï¼Œæ³›å‹çš„çœŸæ­£å¨åŠ›åœ¨äºèƒ½å¤Ÿä¸ºåŸºæœ¬æ³›å‹ç±»å‹å®šä¹‰å…±äº«è¡Œä¸ºï¼Œç„¶åç‹¬ç«‹äºå…·ä½“ç±»å‹ä½¿ç”¨å®ƒã€‚è¿™åœ¨ä½¿ç”¨ Move ä¸­çš„é›†åˆã€æŠ½è±¡å®ç°å’Œå…¶ä»–é«˜çº§åŠŸèƒ½æ—¶ç‰¹åˆ«æœ‰ç”¨ã€‚
```rust
/// A user record with name, age, and some generic metadata
public struct User<T> {
    name: String,
    age: u8,
    /// Varies depending on application.
    metadata: T,
}
```

åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼ŒUseræ˜¯å…·æœ‰å•ä¸ªç±»å‹å‚æ•° çš„æ³›å‹ç±»å‹Tï¼Œå…·æœ‰å…±äº«å­—æ®µ nameå’Œï¼Œä»¥åŠå¯ä»¥å­˜å‚¨ä»»ä½•ç±»å‹çš„ageæ³›å‹å­—æ®µã€‚metadataæ— è®ºæ˜¯ä»€ä¹ˆ metadataï¼Œæ‰€æœ‰å®ä¾‹éƒ½Userå°†å…·æœ‰ç›¸åŒçš„å­—æ®µå’Œæ–¹æ³•ã€‚

```rust
/// Updates the name of the user.
public fun update_name<T>(user: &mut User<T>, name: String) {
    user.name = name;
}

/// Updates the age of the user.
public fun update_age<T>(user: &mut User<T>, age: u8) {
    user.age = age;
}
```

phantom ç±»å‹å‚æ•°
åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæ‚¨å¯èƒ½å¸Œæœ›ä½¿ç”¨æœªåœ¨è¯¥ç±»å‹çš„å­—æ®µæˆ–æ–¹æ³•ä¸­ä½¿ç”¨çš„ç±»å‹å‚æ•°æ¥å®šä¹‰æ³›å‹ç±»å‹ã€‚è¿™ç§°ä¸ºå¹»åƒç±»å‹å‚æ•°ã€‚å½“æ‚¨æƒ³è¦å®šä¹‰å¯ä»¥å®¹çº³ä»»ä½•å…¶ä»–ç±»å‹çš„ç±»å‹ï¼Œä½†æƒ³è¦å¯¹ç±»å‹å‚æ•°å¼ºåˆ¶æ‰§è¡Œä¸€äº›çº¦æŸæ—¶ï¼Œå¹»åƒç±»å‹å‚æ•°éå¸¸æœ‰ç”¨ã€‚
```rust
/// A generic type with a phantom type parameter.
public struct Coin<phantom T> {
    value: u64
}
```

è¿™é‡Œçš„ç±»å‹Coinä¸åŒ…å«ä»»ä½•ä½¿ç”¨ç±»å‹å‚æ•°çš„å­—æ®µæˆ–æ–¹æ³•Tã€‚å®ƒç”¨äºåŒºåˆ†ä¸åŒç±»å‹çš„ç¡¬å¸ï¼Œå¹¶å¯¹ç±»å‹å‚æ•°å¼ºåˆ¶æ‰§è¡Œä¸€äº›çº¦æŸTã€‚

```rust
public struct USD {}
public struct EUR {}

#[test]
fun test_phantom_type() {
let coin1: Coin<USD> = Coin { value: 10 };
let coin2: Coin<EUR> = Coin { value: 20 };

    // Unpacking is identical because the phantom type parameter is not used.
    let Coin { value: _ } = coin1;
    let Coin { value: _ } = coin2;
}
```

åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬æ¼”ç¤ºäº†å¦‚ä½•Coinä½¿ç”¨ä¸åŒçš„å¹»åƒç±»å‹å‚æ•°USDå’Œæ¥åˆ›å»ºä¸¤ä¸ªä¸åŒçš„å®ä¾‹EURã€‚ç±»å‹å‚æ•°Tä¸ç”¨äºç±»å‹çš„å­—æ®µæˆ–æ–¹æ³•ä¸­Coinï¼Œä½†ç”¨äºåŒºåˆ†ä¸åŒç±»å‹çš„å¸ã€‚å®ƒå°†ç¡®ä¿USDå’ŒEURç¡¬å¸ä¸ä¼šæ··æ·†ã€‚

ç±»å‹å‚æ•°çš„çº¦æŸ
ç±»å‹å‚æ•°å¯ä»¥è¢«é™åˆ¶ä¸ºå…·æœ‰æŸäº›èƒ½åŠ›ã€‚å½“æ‚¨éœ€è¦å†…éƒ¨ç±»å‹å…è®¸æŸäº›è¡Œä¸ºï¼ˆä¾‹å¦‚copyæˆ–drop ï¼‰æ—¶ï¼Œè¿™éå¸¸æœ‰ç”¨ã€‚çº¦æŸç±»å‹å‚æ•°çš„è¯­æ³•æ˜¯T: <ability> + <ability>ã€‚

```rust
/// A generic type with a type parameter that has the `drop` ability.
public struct Droppable<T: drop> {
    value: T,
}

/// A generic struct with a type parameter that has the `copy` and `drop` abilities.
public struct CopyableDroppable<T: copy + drop> {
    value: T, // T must have the `copy` and `drop` abilities
}
```

Move Compiler å°†å¼ºåˆ¶ç±»å‹å‚æ•°Tå…·æœ‰æŒ‡å®šçš„åŠŸèƒ½ã€‚å¦‚æœç±»å‹å‚æ•°ä¸å…·æœ‰æŒ‡å®šçš„èƒ½åŠ›ï¼Œåˆ™ä»£ç å°†æ— æ³•ç¼–è¯‘ã€‚

```rust
/// Type without any abilities.
public struct NoAbilities {}

#[test]
fun test_constraints() {
// Fails - `NoAbilities` does not have the `drop` ability
// let droppable = Droppable<NoAbilities> { value: 10 };

    // Fails - `NoAbilities` does not have the `copy` and `drop` abilities
    // let copyable_droppable = CopyableDroppable<NoAbilities> { value: 10 };
}
```



æ³›å‹
æ³›å‹å¯ç”¨äºå®šä¹‰ä¸åŒè¾“å…¥æ•°æ®ç±»å‹çš„å‡½æ•°å’Œç»“æ„ã€‚è¿™ç§è¯­è¨€ç‰¹æ€§æœ‰æ—¶è¢«ç§°ä¸ºå‚æ•°å¤šæ€æ€§ã€‚åœ¨ Move ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸å°†æœ¯è¯­â€œæ³›å‹â€ä¸â€œç±»å‹å‚æ•°â€å’Œâ€œç±»å‹å®å‚â€äº’æ¢ä½¿ç”¨ã€‚

æ³›å‹é€šå¸¸ç”¨åœ¨åº“ä»£ç ä¸­ï¼ˆä¾‹å¦‚åœ¨å‘é‡ä¸­ï¼‰ï¼Œä»¥å£°æ˜é€‚ç”¨äºä»»ä½•å¯èƒ½ç±»å‹ï¼ˆæ»¡è¶³æŒ‡å®šçº¦æŸï¼‰çš„ä»£ç ã€‚è¿™ç§å‚æ•°åŒ–å…è®¸æ‚¨åœ¨å¤šç§ç±»å‹å’Œæƒ…å†µä¸‹é‡ç”¨ç›¸åŒçš„å®ç°ã€‚

å£°æ˜ç±»å‹å‚æ•°
å‡½æ•°å’Œç»“æ„ä½“éƒ½å¯ä»¥åœ¨å…¶ç­¾åä¸­é‡‡ç”¨ç±»å‹å‚æ•°åˆ—è¡¨ï¼Œå¹¶ç”¨ä¸€å¯¹å°–æ‹¬å·æ‹¬èµ·æ¥<...>ã€‚

é€šç”¨å‡½æ•°
å‡½æ•°çš„ç±»å‹å‚æ•°æ”¾ç½®åœ¨å‡½æ•°åç§°ä¹‹åå’Œï¼ˆå€¼ï¼‰å‚æ•°åˆ—è¡¨ä¹‹å‰ã€‚ä»¥ä¸‹ä»£ç å®šä¹‰äº†ä¸€ä¸ªé€šç”¨æ ‡è¯†å‡½æ•°ï¼Œå®ƒæ¥å—ä»»ä½•ç±»å‹çš„å€¼å¹¶è¿”å›è¯¥å€¼ä¸å˜ã€‚
```rust
fun id<T>(x: T): T {
// this type annotation is unnecessary but valid
    (x: T)
}
```

å®šä¹‰åï¼Œç±»å‹å‚æ•°Tå¯ä»¥åœ¨å‚æ•°ç±»å‹ã€è¿”å›ç±»å‹å’Œå‡½æ•°ä½“å†…ä½¿ç”¨ã€‚

é€šç”¨ç»“æ„
ç»“æ„ä½“çš„ç±»å‹å‚æ•°æ”¾ç½®åœ¨ç»“æ„ä½“åç§°ä¹‹åï¼Œå¯ç”¨äºå‘½åå­—æ®µçš„ç±»å‹ã€‚
```rust
public struct Foo<T> has copy, drop { x: T }

public struct Bar<T1, T2> has copy, drop {
    x: T1,
    y: vector<T2>,
}
```

è¯·æ³¨æ„ï¼Œä¸å¿…ä½¿ç”¨ç±»å‹å‚æ•°

ç±»å‹å‚æ•°
è°ƒç”¨æ³›å‹å‡½æ•°
è°ƒç”¨æ³›å‹å‡½æ•°æ—¶ï¼Œå¯ä»¥åœ¨ä¸€å¯¹å°–æ‹¬å·æ‹¬èµ·æ¥çš„åˆ—è¡¨ä¸­æŒ‡å®šå‡½æ•°ç±»å‹å½¢å‚çš„ç±»å‹å®å‚ã€‚
```rust
fun foo() {
    let x = id<bool>(true);
}
```

å¦‚æœæ‚¨ä¸æŒ‡å®šç±»å‹å‚æ•°ï¼ŒMove çš„ç±»å‹æ¨æ–­å°†ä¸ºæ‚¨æä¾›å®ƒä»¬ã€‚

ä½¿ç”¨é€šç”¨ç»“æ„
ç±»ä¼¼åœ°ï¼Œåœ¨æ„é€ æˆ–ææ„æ³›å‹ç±»å‹çš„å€¼æ—¶ï¼Œå¯ä»¥ä¸ºç»“æ„çš„ç±»å‹å‚æ•°é™„åŠ ä¸€ç³»åˆ—ç±»å‹å®å‚ã€‚
```rust
fun foo() {
    // type arguments on construction
    let foo = Foo<bool> { x: true };
    let bar = Bar<u64, u8> { x: 0, y: vector<u8>[] };
    
        // type arguments on destruction
        let Foo<bool> { x } = foo;
        let Bar<u64, u8> { x, y } = bar;
    }
```
åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œå¦‚æœæ‚¨ä¸æŒ‡å®šç±»å‹å‚æ•°ï¼ŒMove çš„ç±»å‹æ¨æ–­éƒ½ä¼šä¸ºæ‚¨æä¾›å®ƒä»¬ã€‚

ç±»å‹å‚æ•°ä¸åŒ¹é…
å¦‚æœæ‚¨æŒ‡å®šç±»å‹å‚æ•°å¹¶ä¸”å®ƒä»¬ä¸æä¾›çš„å®é™…å€¼å†²çªï¼Œåˆ™ä¼šç»™å‡ºé”™è¯¯ï¼š
```rust
fun foo() {
    let x = id<u64>(true); // ERROR! true is not a u64
}
```

ç±»ä¼¼åœ°ï¼š
```rust
fun foo() {
    let foo = Foo<bool> { x: 0 }; // ERROR! 0 is not a bool
    let Foo<address> { x } = foo; // ERROR! bool is incompatible with address
}
```

ç±»å‹æ¨æ–­
åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼ŒMove ç¼–è¯‘å™¨å°†èƒ½å¤Ÿæ¨æ–­ç±»å‹å‚æ•°ï¼Œå› æ­¤æ‚¨ä¸å¿…æ˜¾å¼å†™ä¸‹å®ƒä»¬ã€‚å¦‚æœæˆ‘ä»¬çœç•¥ç±»å‹å‚æ•°ï¼Œä¸Šé¢çš„ç¤ºä¾‹å°†å¦‚ä¸‹æ‰€ç¤ºï¼š
```rust
fun foo() {
let x = id(true);
//        ^ <bool> is inferred

    let foo = Foo { x: true };
    //           ^ <bool> is inferred

    let Foo { x } = foo;
    //     ^ <bool> is inferred
}
```

æ³¨æ„ï¼šå½“ç¼–è¯‘å™¨æ— æ³•æ¨æ–­ç±»å‹æ—¶ï¼Œæ‚¨éœ€è¦æ‰‹åŠ¨æ³¨é‡Šå®ƒä»¬ã€‚ä¸€ç§å¸¸è§çš„æƒ…å†µæ˜¯è°ƒç”¨ä»…å‡ºç°åœ¨è¿”å›ä½ç½®çš„ç±»å‹å‚æ•°çš„å‡½æ•°ã€‚
```move
module a::m {

    fun foo() {
        let v = vector[]; // ERROR!
        //            ^ The compiler cannot figure out the element type, since it is never used

        let v = vector<u64>[];
        //            ^~~~~ Must annotate manually in this case.
    }
}
```

è¯·æ³¨æ„ï¼Œè¿™äº›æƒ…å†µæœ‰ç‚¹äººä¸ºï¼Œå› ä¸ºvector[]ä»æœªä½¿ç”¨è¿‡ï¼Œå› æ­¤ï¼ŒMove çš„ç±»å‹æ¨æ–­æ— æ³•æ¨æ–­ç±»å‹ã€‚

ä½†æ˜¯ï¼Œå¦‚æœç¨ååœ¨è¯¥å‡½æ•°ä¸­ä½¿ç”¨è¯¥å€¼ï¼Œç¼–è¯‘å™¨å°†èƒ½å¤Ÿæ¨æ–­å‡ºç±»å‹ï¼š
```rust
module a::m {
fun foo() {
    let v = vector[];
    //            ^ <u64> is inferred
    vector::push_back(&mut v, 42);
    //               ^ <u64> is inferred
    }
}
```

### æ•´æ•°
åœ¨ Move ä¸­ï¼Œæ•´æ•°ç±»å‹u8ã€u16ã€u32ã€u64ã€u128å’Œu256éƒ½æ˜¯ä¸åŒçš„ç±»å‹ã€‚ç„¶è€Œï¼Œè¿™äº›ç±»å‹ä¸­çš„æ¯ä¸€ç§éƒ½å¯ä»¥ä½¿ç”¨ç›¸åŒçš„æ•°å€¼è¯­æ³•æ¥åˆ›å»ºã€‚æ¢å¥è¯è¯´ï¼Œå¦‚æœæœªæä¾›ç±»å‹åç¼€ï¼Œç¼–è¯‘å™¨å°†æ ¹æ®å€¼çš„ç”¨æ³•æ¨æ–­æ•´æ•°ç±»å‹ã€‚
```rust
let x8: u8 = 0;
let x16: u16 = 0;
let x32: u32 = 0;
let x64: u64 = 0;
let x128: u128 = 0;
let x256: u256 = 0;
```

å¦‚æœè¯¥å€¼æœªåœ¨éœ€è¦ç‰¹å®šæ•´æ•°ç±»å‹çš„ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨ï¼Œu64åˆ™å°†å…¶è§†ä¸ºé»˜è®¤å€¼ã€‚
```rust
let x = 0;
//      ^ u64 is used by default
```

ä½†æ˜¯ï¼Œå¦‚æœè¯¥å€¼å¯¹äºæ¨æ–­çš„ç±»å‹å¤ªå¤§ï¼Œåˆ™ä¼šç»™å‡ºé”™è¯¯
```rust
let i: u8 = 256; // ERROR!
//          ^^^ too large for u8
let x = 340282366920938463463374607431768211454;
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ too large for u64
```

å¦‚æœæ•°å­—å¤ªå¤§ï¼Œæ‚¨å¯èƒ½éœ€è¦æ˜¾å¼æ³¨é‡Šå®ƒ
```rust
let x = 340282366920938463463374607431768211454u128;
//                                             ^^^^ valid!
```

æœªä½¿ç”¨çš„ç±»å‹å‚æ•°
å¯¹äºç»“æ„ä½“å®šä¹‰ï¼Œæœªä½¿ç”¨çš„ç±»å‹å‚æ•°æ˜¯æŒ‡æœªå‡ºç°åœ¨ç»“æ„ä½“ä¸­å®šä¹‰çš„ä»»ä½•å­—æ®µä¸­çš„ç±»å‹å‚æ•°ï¼Œä½†ä¼šåœ¨ç¼–è¯‘æ—¶é™æ€æ£€æŸ¥ã€‚ Move å…è®¸æœªä½¿ç”¨çš„ç±»å‹å‚æ•°ï¼Œå› æ­¤ä»¥ä¸‹ç»“æ„å®šä¹‰æœ‰æ•ˆï¼š
```rust
public struct Foo<T> {
    foo: u64
}
```

è¿™åœ¨å¯¹æŸäº›æ¦‚å¿µè¿›è¡Œå»ºæ¨¡æ—¶éå¸¸æ–¹ä¾¿ã€‚è¿™æ˜¯ä¸€ä¸ªä¾‹å­ï¼š
```rust
module a::m {
// Currency Specifiers
public struct A {}
public struct B {}

    // A generic coin type that can be instantiated using a currency
    // specifier type.
    //   e.g. Coin<A>, Coin<B> etc.
    public struct Coin<Currency> has store {
        value: u64
    }

    // Write code generically about all currencies
    public fun mint_generic<Currency>(value: u64): Coin<Currency> {
        Coin { value }
    }

    // Write code concretely about one currency
    public fun mint_a(value: u64): Coin<A> {
        mint_generic(value)
    }
    public fun mint_b(value: u64): Coin<B> {
        mint_generic(value)
    }
}
```

åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼ŒCoin<Currency>æ˜¯ç±»å‹å‚æ•°çš„é€šç”¨ç±»å‹Currencyï¼Œå®ƒæŒ‡å®šç¡¬å¸çš„è´§å¸ï¼Œå¹¶å…è®¸é€šç”¨åœ°é’ˆå¯¹ä»»ä½•è´§å¸æˆ–å…·ä½“åœ°é’ˆå¯¹ç‰¹å®šè´§å¸ç¼–å†™ä»£ç ã€‚å³ä½¿Currencyç±»å‹å‚æ•°æ²¡æœ‰å‡ºç°åœ¨ ä¸­å®šä¹‰çš„ä»»ä½•å­—æ®µä¸­ï¼Œè¿™ç§é€šç”¨æ€§ä¹Ÿé€‚ç”¨Coinã€‚

è™šæ‹Ÿç±»å‹å‚æ•°
åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œè™½ç„¶struct Coinè¦æ±‚æœ‰storeèƒ½åŠ›ï¼Œä½†æ—¢æ²¡æœ‰Coin<A>ä¹Ÿ Coin<B>æ²¡æœ‰storeèƒ½åŠ›ã€‚è¿™æ˜¯å› ä¸ºæ¡ä»¶èƒ½åŠ›å’Œé€šç”¨ç±»å‹çš„è§„åˆ™ ä»¥åŠAå’ŒBæ²¡æœ‰èƒ½åŠ› çš„äº‹å®storeï¼Œå°½ç®¡äº‹å®ä¸Šå®ƒä»¬ç”šè‡³æ²¡æœ‰åœ¨ çš„ä¸»ä½“ä¸­ä½¿ç”¨struct Coinã€‚è¿™å¯èƒ½ä¼šå¯¼è‡´ä¸€äº›ä¸æ„‰å¿«çš„åæœã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬æ— æ³•å°†å…¶æ”¾å…¥Coin<A>é’±åŒ…ä¸­å­˜å‚¨ã€‚

ä¸€ç§å¯èƒ½çš„è§£å†³æ–¹æ¡ˆæ˜¯å‘Aå’Œæ·»åŠ è™šå‡èƒ½åŠ›æ³¨é‡ŠBï¼ˆå³ public struct Currency1 has store {}ï¼‰ã€‚ä½†æ˜¯ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´é”™è¯¯æˆ–å®‰å…¨æ¼æ´ï¼Œå› ä¸ºå®ƒå‰Šå¼±äº†ä¸å¿…è¦çš„èƒ½åŠ›å£°æ˜çš„ç±»å‹ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬æ°¸è¿œä¸ä¼šæœŸæœ›å­˜å‚¨ä¸­çš„å€¼å…·æœ‰ç±»å‹ä¸º çš„å­—æ®µAï¼Œä½†è¿™é€šè¿‡è™šå‡èƒ½åŠ›æ˜¯å¯èƒ½çš„storeã€‚æ­¤å¤–ï¼Œè™šå‡æ³¨é‡Šå…·æœ‰ä¼ æŸ“æ€§ï¼Œè¦æ±‚æœªä½¿ç”¨çš„ç±»å‹å‚æ•°ä¸Šçš„è®¸å¤šé€šç”¨å‡½æ•°ä¹ŸåŒ…å«å¿…è¦çš„çº¦æŸã€‚

å¹»åƒç±»å‹å‚æ•°è§£å†³äº†è¿™ä¸ªé—®é¢˜ã€‚æœªä½¿ç”¨çš„ç±»å‹å‚æ•°å¯ä»¥æ ‡è®°ä¸ºå¹»åƒç±»å‹å‚æ•°ï¼Œå®ƒä»¬ä¸å‚ä¸ç»“æ„ä½“çš„èƒ½åŠ›æ¨å¯¼ã€‚è¿™æ ·ï¼Œåœ¨æ´¾ç”Ÿæ³›å‹ç±»å‹çš„èƒ½åŠ›æ—¶ï¼Œä¸ä¼šè€ƒè™‘å¹»åƒç±»å‹å‚æ•°çš„å®å‚ï¼Œä»è€Œé¿å…äº†è™šå‡èƒ½åŠ›æ³¨é‡Šçš„éœ€è¦ã€‚ä¸ºäº†ä½¿è¿™ä¸ªå®½æ¾çš„è§„åˆ™åˆç†ï¼ŒMove çš„ç±»å‹ç³»ç»Ÿä¿è¯å£°æ˜ä¸º çš„å‚æ•°phantomè¦ä¹ˆåœ¨ç»“æ„å®šä¹‰ä¸­æ ¹æœ¬ä¸ä½¿ç”¨ï¼Œè¦ä¹ˆä»…ç”¨ä½œä¹Ÿå£°æ˜ä¸º çš„ç±»å‹å‚æ•°çš„å®å‚phantomã€‚


phantomåœ¨ç»“æ„å®šä¹‰ä¸­ï¼Œå¯ä»¥é€šè¿‡åœ¨å£°æ˜å‰æ·»åŠ å…³é”®å­—å°†ç±»å‹å‚æ•°å£°æ˜ä¸ºå¹»åƒã€‚
```rust
public struct Coin<phantom Currency> has store {
    value: u64
}
```

å¦‚æœç±»å‹å‚æ•°è¢«å£°æ˜ä¸ºå¹»åƒï¼Œæˆ‘ä»¬å°±è¯´å®ƒæ˜¯å¹»åƒç±»å‹å‚æ•°ã€‚å®šä¹‰ç»“æ„æ—¶ï¼ŒMove çš„ç±»å‹æ£€æŸ¥å™¨ç¡®ä¿æ¯ä¸ªå¹»åƒç±»å‹å‚æ•°ä¸åœ¨ç»“æ„å®šä¹‰å†…ä½¿ç”¨ï¼Œæˆ–è€…ä»…ç”¨ä½œå¹»åƒç±»å‹å‚æ•°çš„å®å‚ã€‚
```rust
public struct S1<phantom T1, T2> { f: u64 }
//               ^^^^^^^ valid, T1 does not appear inside the struct definition

public struct S2<phantom T1, T2> { f: S1<T1, T2> }
//               ^^^^^^^ valid, T1 appears in phantom position
ä»¥ä¸‹ä»£ç æ˜¾ç¤ºäº†è¿åè§„åˆ™çš„ç¤ºä¾‹ï¼š

public struct S1<phantom T> { f: T }
//               ^^^^^^^ ERROR!  ^ Not a phantom position

public struct S2<T> { f: T }
public struct S3<phantom T> { f: S2<T> }
//               ^^^^^^^ ERROR!     ^ Not a phantom position
```


æ›´æ­£å¼åœ°è¯´ï¼Œå¦‚æœæŸä¸ªç±»å‹ç”¨ä½œå¹»åƒç±»å‹å½¢å‚çš„å®å‚ï¼Œæˆ‘ä»¬å°±è¯´è¯¥ç±»å‹å‡ºç°åœ¨å¹»åƒä½ç½®ã€‚æœ‰äº†è¿™ä¸ªå®šä¹‰ï¼Œæ­£ç¡®ä½¿ç”¨å¹»åƒå‚æ•°çš„è§„åˆ™å¯ä»¥æŒ‡å®šå¦‚ä¸‹ï¼šå¹»åƒç±»å‹å‚æ•°åªèƒ½å‡ºç°åœ¨å¹»åƒä½ç½®ã€‚

è¯·æ³¨æ„ï¼ŒæŒ‡å®šphantomä¸æ˜¯å¿…éœ€çš„ï¼Œä½†å¦‚æœç±»å‹å‚æ•°å¯ä»¥phantomä½†æœªæ ‡è®°ä¸ºæ­¤ç±»ï¼Œåˆ™ç¼–è¯‘å™¨å°†å‘å‡ºè­¦å‘Šã€‚

å®ä¾‹åŒ–
å®ä¾‹åŒ–ç»“æ„ä½“æ—¶ï¼Œåœ¨æ´¾ç”Ÿç»“æ„ä½“åŠŸèƒ½æ—¶å°†æ’é™¤å¹»åƒå‚æ•°çš„å®å‚ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ä»¥ä¸‹ä»£ç ï¼š
```rust
public struct S<T1, phantom T2> has copy { f: T1 }
public struct NoCopy {}
public struct HasCopy has copy {}
```

ç°åœ¨è€ƒè™‘ç±»å‹S<HasCopy, NoCopy>ã€‚ç”±äºSæ˜¯ç”¨ å®šä¹‰çš„copyï¼Œå¹¶ä¸”æ‰€æœ‰éå¹»è±¡å‚æ•°éƒ½æœ‰copyé‚£ä¹ˆS<HasCopy, NoCopy>ä¹Ÿæœ‰copyã€‚

å…·æœ‰èƒ½åŠ›é™åˆ¶çš„å¹»åƒç±»å‹å‚æ•°
èƒ½åŠ›çº¦æŸå’Œè™šæ‹Ÿç±»å‹å‚æ•°æ˜¯æ­£äº¤ç‰¹å¾ï¼Œå› ä¸ºè™šæ‹Ÿå‚æ•°å¯ä»¥ç”¨èƒ½åŠ›çº¦æŸæ¥å£°æ˜ã€‚
```rust
public struct S<phantom T: copy> {}
```

å½“å®ä¾‹åŒ–å…·æœ‰èƒ½åŠ›çº¦æŸçš„å¹»åƒç±»å‹å‚æ•°æ—¶ï¼Œç±»å‹å®å‚å¿…é¡»æ»¡è¶³è¯¥çº¦æŸï¼Œå³ä½¿è¯¥å‚æ•°æ˜¯å¹»åƒçš„ã€‚é€šå¸¸çš„é™åˆ¶é€‚ç”¨ï¼Œå¹¶ä¸”T åªèƒ½ä½¿ç”¨å…·æœ‰ çš„å‚æ•°è¿›è¡Œå®ä¾‹åŒ–copyã€‚

çº¦æŸæ¡ä»¶
åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬æ¼”ç¤ºäº†å¦‚ä½•ä½¿ç”¨ç±»å‹å‚æ•°æ¥å®šä¹‰å¯ç”±è°ƒç”¨è€…ç¨åæ’å…¥çš„â€œæœªçŸ¥â€ç±»å‹ã€‚ç„¶è€Œï¼Œè¿™æ„å‘³ç€ç±»å‹ç³»ç»Ÿå‡ ä¹æ²¡æœ‰å…³äºç±»å‹çš„ä¿¡æ¯ï¼Œå¹¶ä¸”å¿…é¡»ä»¥éå¸¸ä¿å®ˆçš„æ–¹å¼æ‰§è¡Œæ£€æŸ¥ã€‚ä»æŸç§æ„ä¹‰ä¸Šè¯´ï¼Œç±»å‹ç³»ç»Ÿå¿…é¡»å‡è®¾ä¸å—çº¦æŸçš„æ³›å‹çš„æœ€åæƒ…å†µâ€”â€”æ²¡æœ‰èƒ½åŠ›çš„ç±»å‹ã€‚

çº¦æŸæä¾›äº†ä¸€ç§æ–¹æ³•æ¥æŒ‡å®šè¿™äº›æœªçŸ¥ç±»å‹å…·æœ‰å“ªäº›å±æ€§ï¼Œä»¥ä¾¿ç±»å‹ç³»ç»Ÿå¯ä»¥å…è®¸å¦åˆ™ä¸å®‰å…¨çš„æ“ä½œã€‚

å£°æ˜çº¦æŸ
å¯ä»¥ä½¿ç”¨ä»¥ä¸‹è¯­æ³•å¯¹ç±»å‹å‚æ•°æ–½åŠ çº¦æŸã€‚
```rust
// T is the name of the type parameter
T: <ability> (+ <ability>)*
```

å¯ä»¥<ability>æ˜¯å››ç§èƒ½åŠ›ä¸­çš„ä»»ä½•ä¸€ç§ï¼Œå¹¶ä¸”ä¸€ä¸ªç±»å‹å‚æ•°å¯ä»¥åŒæ—¶å—åˆ°å¤šç§èƒ½åŠ›çš„çº¦æŸã€‚å› æ­¤ä»¥ä¸‹æ‰€æœ‰å†…å®¹éƒ½æ˜¯æœ‰æ•ˆçš„ç±»å‹å‚æ•°å£°æ˜ï¼š
```rust
T: copy
T: copy + drop
T: copy + drop + store + key
```

éªŒè¯çº¦æŸ
åœ¨å®ä¾‹åŒ–ç«™ç‚¹æ£€æŸ¥çº¦æŸ
```rust
public struct Foo<T: copy> { x: T }

public struct Bar { x: Foo<u8> }
//                         ^^ valid, u8 has `copy`

public struct Baz<T> { x: Foo<T> }
//                            ^ ERROR! T does not have 'copy'
```

å¯¹äºå‡½æ•°ä¹Ÿç±»ä¼¼
```rust
fun unsafe_consume<T>(x: T) {
    // ERROR! x does not have 'drop'
}

fun consume<T: drop>(x: T) {
    // valid, x will be dropped automatically
}

public struct NoAbilities {}

fun foo() {
    let r = NoAbilities {};
    consume<NoAbilities>(NoAbilities);
    //      ^^^^^^^^^^^ ERROR! NoAbilities does not have 'drop'
}
```

è¿˜æœ‰ä¸€äº›ç±»ä¼¼çš„ä¾‹å­ï¼Œä½†æ˜¯copy
```rust
fun unsafe_double<T>(x: T) {
(copy x, x)
// ERROR! T does not have 'copy'
}

fun double<T: copy>(x: T) {
(copy x, x) // valid, T has 'copy'
}

public struct NoAbilities {}

fun foo(): (NoAbilities, NoAbilities) {
let r = NoAbilities {};
double<NoAbilities>(r)
//     ^ ERROR! NoAbilities does not have 'copy'
}
```

æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…æœ‰å…³æ¡ä»¶èƒ½åŠ›å’Œæ³›å‹ç±»å‹çš„èƒ½åŠ›éƒ¨åˆ† ã€‚

é€’å½’çš„é™åˆ¶
é€’å½’ç»“æ„
æ³›å‹ç»“æ„ä¸èƒ½ç›´æ¥æˆ–é—´æ¥åŒ…å«ç›¸åŒç±»å‹çš„å­—æ®µï¼Œå³ä½¿å…·æœ‰ä¸åŒçš„ç±»å‹å‚æ•°ä¹Ÿæ˜¯å¦‚æ­¤ã€‚ä»¥ä¸‹æ‰€æœ‰ç»“æ„å®šä¹‰å‡æ— æ•ˆï¼š
```rust
public struct Foo<T> {
    x: Foo<u64> // ERROR! 'Foo' containing 'Foo'
}

public struct Bar<T> {
    x: Bar<T> // ERROR! 'Bar' containing 'Bar'
}

// ERROR! 'A' and 'B' forming a cycle, which is not allowed either.
public struct A<T> {
    x: B<T, u64>
}

public struct B<T1, T2> {
    x: A<T1>
    y: A<T2>
}
```

### é«˜çº§ä¸»é¢˜ï¼šç±»å‹çº§é€’å½’
Move å…è®¸é€’å½’è°ƒç”¨é€šç”¨å‡½æ•°ã€‚ç„¶è€Œï¼Œå½“ä¸æ³›å‹ç»“æ„ç»“åˆä½¿ç”¨æ—¶ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹å¯èƒ½ä¼šåˆ›å»ºæ— é™æ•°é‡çš„ç±»å‹ï¼Œå¹¶ä¸”å…è®¸è¿™æ„å‘³ç€ç»™ç¼–è¯‘å™¨ã€è™šæ‹Ÿæœºå’Œå…¶ä»–è¯­è¨€ç»„ä»¶å¢åŠ ä¸å¿…è¦çš„å¤æ‚æ€§ã€‚å› æ­¤ï¼Œè¿™æ ·çš„é€’å½’æ˜¯è¢«ç¦æ­¢çš„ã€‚

æ­¤é™åˆ¶å°†æ¥å¯èƒ½ä¼šæ”¾å®½ï¼Œä½†å°±ç›®å‰è€Œè¨€ï¼Œä»¥ä¸‹ç¤ºä¾‹åº”è¯¥è®©æ‚¨äº†è§£ä»€ä¹ˆæ˜¯å…è®¸çš„ï¼Œä»€ä¹ˆæ˜¯ä¸å…è®¸çš„ã€‚
```rust
module a::m {
public struct A<T> {}

    // Finitely many types -- allowed.
    // foo<T> -> foo<T> -> foo<T> -> ... is valid
    fun foo<T>() {
        foo<T>();
    }

    // Finitely many types -- allowed.
    // foo<T> -> foo<A<u64>> -> foo<A<u64>> -> ... is valid
    fun foo<T>() {
        foo<A<u64>>();
    }
}
```

ä¸å…è®¸ï¼š
```move
module a::m {
    public struct A<T> {}

    // Infinitely many types -- NOT allowed.
    // error!
    // foo<T> -> foo<A<T>> -> foo<A<A<T>>> -> ...
    fun foo<T>() {
        foo<Foo<T>>();
    }
}
```

åŒæ ·ï¼Œä¸å…è®¸ï¼š

```move
module a::n {
public struct A<T> {}

    // Infinitely many types -- NOT allowed.
    // error!
    // foo<T1, T2> -> bar<T2, T1> -> foo<T2, A<T1>>
    //   -> bar<A<T1>, T2> -> foo<A<T1>, A<T2>>
    //   -> bar<A<T2>, A<T1>> -> foo<A<T2>, A<A<T1>>>
    //   -> ...
    fun foo<T1, T2>() {
        bar<T2, T1>();
    }

    fun bar<T1, T2> {
        foo<T1, A<T2>>();
    }
}
```

è¯·æ³¨æ„ï¼Œç±»å‹çº§åˆ«é€’å½’çš„æ£€æŸ¥åŸºäºå¯¹è°ƒç”¨ç«™ç‚¹çš„ä¿å®ˆåˆ†æï¼Œå¹¶ä¸”ä¸è€ƒè™‘æ§åˆ¶æµæˆ–è¿è¡Œæ—¶å€¼ã€‚
```move
module a::m {
public struct A<T> {}

    // Infinitely many types -- NOT allowed.
    // error!
    fun foo<T>(n: u64) {
        if (n > 0) foo<A<T>>(n - 1);
    }
}
```

ä¸Šé¢ç¤ºä¾‹ä¸­çš„å‡½æ•°åœ¨æŠ€æœ¯ä¸Šå°†é’ˆå¯¹ä»»ä½•ç»™å®šè¾“å…¥ç»ˆæ­¢ï¼Œå› æ­¤ä»…åˆ›å»ºæœ‰é™å¤šä¸ªç±»å‹ï¼Œä½† Move çš„ç±»å‹ç³»ç»Ÿä»ç„¶è®¤ä¸ºå®ƒæ— æ•ˆã€‚

